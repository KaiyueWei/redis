// stdlib
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
// system 
#include <fcntl.h>
#include <poll.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/ip.h>
// C++
#include <vector>

static void msg(const char *msg){
	fprintf(stderr, "%s\n", msg);
}

static void msg_errno(const char *msg){
	fprintf(stderr, "[errno:%d] %s\n", errno, msg);
}

static void die(const char *msg){
	fprintf(stderr, "[%d] %s\n", errno, msg);	
	abort();
}
/*
 * No-blocking set up
 * read and write never blocks
 */
static void fd_set_nb(int fd){
	errno = 0;
	int flags = fcntl(fd, F_GETFL, 0);
	if (errno){
		die("fcntl error");
		return;
	}
	flags |= O_NONBLOCK;

	errno = 0;
	(void)fcntl(fd, F_SETFL, flags);
	if(errno){
		die("fcntl error");
	}
}

const size_t k_max_msg = 32 << 20; // likerly larger tah the kernel buffer
typedef struct Buffer {
	uint8_t *buffer_begin;
	uint8_t *buffer_end;
	uint8_t *data_begin;
	uint8_t *data_end;
}Buffer;


static void buf_init(Buffer *buf, size_t cap){
	buf->buffer_begin = (uint8_t*)malloc(cap);
	buf->buffer_end = buf->buffer_begin + cap;
	buf->data_begin = buf->buffer_begin;
	buf->data_end = buf->buffer_begin;
}

static void buf_free(Buffer *buf){
	if(buf->buffer_begin){
		free(buf->buffer_begin);
	}
	buf->buffer_begin = NULL;
	buf->buffer_end = NULL;
	buf->data_begin = NULL;
	buf->data_end = NULL;
}

static size_t buf_size(const Buffer *buf){
	return (size_t)(buf->data_end - buf->data_begin);
}

static size_t buf_capacity(const Buffer *buf){
	return (size_t)(buf->buffer_end - buf->data_end);
}


static bool buf_append(Buffer *buf, const uint8_t *data, size_t n){
	if(buf_capacity(buf) < n){
		return false;
	}
	memcpy(buf->data_end, data, n);
	buf->data_end += n;
	return true;
}

static void buf_consume(Buffer *buf, size_t n){
	assert( n <= buf_size(buf));
	buf->data_begin += n;
	// reset pointers when empty
	if (buf->data_begin == buf->data_end){
		buf->data_begin = buf->buffer_begin;
		buf->data_end = buf->buffer_begin;
	}	
}


/*
 * Each connection has:
 * 1). state flags: this tells the event loop what to poll for
 * 	want_read -> poll for POLLIN
 * 	want_write -> poll for POLLOUT
 * 	want_close -> close socket
 * 2). buffers
 * 	incoming: raw bytes read fro socket
 * 	outgoing: bytes waiting to be written
 */
struct Conn {
	int fd = -1;
	// application's intention, for the event loop
	bool want_read = false;
	bool want_write = false;
	bool want_close = false;
	// buffered input and output
	struct Buffer incoming; //data to be parsed by the application
	struct Buffer outgoing; // responses generated by the application

};

/*
 * std::vector as a FIFO
 * appending to the back is efficient for dynamic arrays because it doesn't reallocate each time
 * its capacity grows exponentially to amortize the reallocation cost
 * but removing stuff from the front is not efficient because it has to move the rest of the data
 * each time
// append to the back
static void buf_append(std::vector<uint8_t> &buf, const uint8_t *data, size_t len){
	buf.insert(buf.end(), data, data + len);
}


// remove from the front
static void buf_consume(std::vector<uint8_t> &buf, size_t n){
	buf.erase(buf.begin(), buf.begin() + n);
}

*/

/*
 *  accept new connections
 *  steps:
 *  1). accept() new client
 *  2). set non-blocking
 *  3). allocate conn
 *  4). start with want_read = true
 */
static Conn *handle_accept(int fd){
	// accept
	struct sockaddr_in client_addr = {};
	socklen_t addrlen = sizeof(client_addr);
	int connfd = accept(fd, (struct sockaddr *)&client_addr, &addrlen);
	if(connfd < 0){
		msg_errno("accept() error");
		return NULL;
	}
	uint32_t ip = client_addr.sin_addr.s_addr;
	fprintf(stderr, "new client from %u.%u.%u.%u:%u\n",
					ip & 255, (ip >> 8) & 255, (ip >> 16) & 255, ip >> 24,
					ntohs(client_addr.sin_port)
			);
	// set the new connection fd t nonblocking mode
	fd_set_nb(connfd);
	// create a `struct Conn`
	Conn *conn = new Conn();
	conn->fd = connfd;
	conn->want_read = true;
	buf_init(&conn->incoming, k_max_msg);	
	buf_init(&conn->outgoing, k_max_msg);
	return conn;	
}

/*
 * handle multiple requests without concurrency
static int32_t read_full(int fd, char *buf, size_t n){
	while (n > 0){
		ssize_t rv = read(fd, buf, n);
		if(rv <= 0){
			return -1; //error, or unexpected EOF
		}
		assert((size_t)rv <= n);
		n -= (size_t)rv;
		buf += rv;
	}
	return 0;
}

static int32_t write_all(int fd, const char *buf, size_t n){
	while (n > 0){
		ssize_t rv = write(fd, buf, n);
		if(rv <= 0){
			return -1; // error
		}
		assert((size_t)rv <= n);
		n -= (size_t)rv;
		buf += rv;
	}
	return 0;
}
*/

/* process 1 request if there is enough data
 * consumes exactly one request
 * true -> successfully parsed one request
 * false -> need more data or error
 * steps:
 * 1). check header
 * 2). read length
 * 3). check full body
 * 4). application logic (echo for now)
 * 5). consume input
 */
static bool try_one_request(Conn *conn){
	// try to parse the protocol: message header
	if (buf_size(&conn->incoming) < 4){
		return false; // want read
	}
	uint32_t len = 0;
	memcpy(&len, conn->incoming.data_begin, 4);
	if(len > k_max_msg){
		msg("too long");
		conn->want_close = true;
		return false; // want close
	}
	// message body
	if ( 4 + len > buf_size(&conn->incoming)){
		return false; // want read
	}
	const uint8_t *request = conn->incoming.data_begin + 4;

	// got one request, do some application logic
	printf("client says: len:%d data:%.*s\n",
					len, len < 100 ? len : 100, request);
	// generate the response (echo)
	buf_append(&conn->outgoing, (const uint8_t *)&len, 4);
	buf_append(&conn->outgoing, request, len);

	// application logic done! remove the request message
	buf_consume(&conn->incoming, 4 + len);
	return true; // success
}
/*
 * handle one msg
static void do_something(int connfd){
	char rbuf[64] = {};
	ssize_t n = read(connfd, rbuf, sizeof(rbuf) - 1);
	if (n < 0){
		msg("read() error");
		return;
	}
	fprintf(stderr, "client says: %s\n", rbuf);
	char wbuf[] = "world";
	write(connfd, wbuf, strlen(wbuf));
}
*/

/* application callback when the socket is writable
 * write as much as kernel accepts
 * partial writes are normal
 * remaining bytes stay in outgoing
 */
static void handle_write(Conn *conn){
	assert(buf_size(&conn->outgoing) > 0);
	ssize_t rv = write(conn->fd, conn->outgoing.data_begin, buf_size(&conn->outgoing));
	if (rv < 0 && errno == EAGAIN){
		return; // actually not ready
	}
	if (rv < 0){
		msg_errno("write() error");
		conn->want_close = true; // error handling
		return;
	}

	// remove written data from `outgoing`
	buf_consume(&conn->outgoing, (size_t)rv);

	// update the readiness intention
	if (buf_size(&conn->outgoing) == 0){ // all data written
		conn->want_read = true;
		conn->want_write = false;
	} // else: want write

}

/*
 * application callback when the socket is readable
 * step:
 * 1). read as much as possible, might read:
 * - half a request 
 * - one request 
 * - many requests
 * 2). append to input buffer
 * 3). parse requests in a loop 
 */
static void handle_read(Conn *conn){
	// read some data
	uint8_t buf[64 * 1024];
	ssize_t rv = read(conn->fd, buf, sizeof(buf));
	if (rv < 0 && errno == EAGAIN){
		return; // actually not ready
	}
	// handle IO error
	if (rv < 0){
		msg_errno("read() error");
		conn->want_close = true;
		return; // want close
	}
	// handle EOF
	if ( rv == 0){
		if (buf_size(&conn->incoming) == 0){
			msg("client closed");
		}else{
			msg("unexpected EOF");
		}
		conn->want_close = true;
		return; // want close
	}
	// get some new data
	if (!buf_append(&conn->incoming, buf, (size_t)rv)){
		msg("incoming buffer overflow");
		conn->want_close = true;
		return;
	}

	// parse requests and generate reponses
	while (try_one_request(conn)){
	}
	
	// update the readiness intention
	if (buf_size(&conn->outgoing) > 0){
		conn->want_read = false;
		conn->want_write = true;	
		// The socket is likely ready to write in a request-response protocol,
		// try to write it without waiting for the next iteration
		return handle_write(conn);
	} // else: want read

}



int main(){
	// the listening socket
	int fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd < 0) {
		die("socket()");	
	}
	// this is needed for most server applications
	int val = 1;
	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));

	// bind
	struct sockaddr_in addr = {};

	addr.sin_family = AF_INET;
	addr.sin_port = ntohs(1234);
	addr.sin_addr.s_addr = ntohl(0); // wildcard address 0.0.0.0
	int rv = bind(fd, (const struct sockaddr *)&addr, sizeof(addr));
	if (rv){
		die("bind()");
	}

	// listen
	rv = listen(fd, SOMAXCONN);
	if(rv){
		die("listen()");
	}
	
	// a map of all client connections, keyed by fd
	std::vector<Conn *> fd2conn;
	// the event loop
	std::vector<struct pollfd> poll_args;
	while (true){
		// prepare the arguments of the poll()
		poll_args.clear();
		// put the listening sockets in the first position
		struct pollfd pfd = {fd, POLLIN, 0};
		poll_args.push_back(pfd);
		// the rest are connection sockets
		for (Conn *conn : fd2conn){
			if (!conn){
				continue;
			}
			// always poll() for error
			struct pollfd pfd = {conn->fd, POLLERR, 0};
			// poll() flags from the application's intent
			if (conn->want_read){
				pfd.events |= POLLIN;
		   	}
			if (conn->want_write){
				pfd.events |= POLLOUT; 
			}
			poll_args.push_back(pfd);
		}
		// wait for readiness
		int rv = poll(poll_args.data(), (nfds_t)poll_args.size(), -1);
		if (rv < 0 && errno == EINTR){
			continue; // not an error
		}
		if (rv < 0){
			die("poll");

		}
		// handle the listening socket
		if (poll_args[0].revents){
			if (Conn *conn = handle_accept(fd)){
				// put it int the map
				if (fd2conn.size() <= (size_t)conn->fd){
					fd2conn.resize(conn->fd + 1);

				}
				assert(!fd2conn[conn->fd]);
				fd2conn[conn->fd] = conn;
			}

		}
		// handle connection sockets
		for (size_t i = 1; i < poll_args.size(); ++i){ // skip the first
			uint32_t ready = poll_args[i].revents;
			if (ready == 0){
				continue;
			}
			Conn *conn = fd2conn[poll_args[i].fd];
			if (ready & POLLIN){
				assert(conn->want_read);
				handle_read(conn); // application logic
			}
			if (ready & POLLOUT){
				assert(conn->want_write);
				handle_write(conn); // application logic
			}
			// close the socket from socket error or application logic
			if ((ready & POLLERR) || conn->want_close){
				(void)close(conn->fd);
				buf_free(&conn->incoming);
				buf_free(&conn->outgoing);
				fd2conn[conn->fd] = NULL;
				delete conn;

			}
		} // for each connection sockets
	} // the event loop
	return 0;
}
